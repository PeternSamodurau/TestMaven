package lesson_21.by_ChuckNorris.K_LockInterface_and_ReentrantLock.Call;

//Lock - интерфейс , который имплементируется классом ReentrantLock и нужен для синхронизаии между потоками

//Многопоточность важна, когда у вас есть несколько задач, которые могут выполняться параллельно.
// Однако, в некоторых случаях, вам может потребоваться синхронизация потоков, чтобы предотвратить одновременный доступ к общим ресурсам.
// Это именно то, что делает ReentrantLock.
//
//Ваш пример с использованием ReentrantLock это способ гарантировать, что только один поток будет выполнять метод
// mobileCall(), skypeCall(), или viberCall() в любой момент времени.
// Это может быть полезно, если эти методы изменяют общие данные или ресурсы и вам нужно предотвратить условия гонки.
//
//Однако, это не означает, что все многопоточные программы должны выполняться последовательно.
// Во многих случаях, вы можете позволить потокам работать параллельно, что может значительно увеличить производительность вашей программы,
// особенно на многоядерных процессорах.
//
//В общем, выбор между параллельной и последовательной обработкой зависит от конкретной задачи.
// Если потоки могут работать независимо и безопасно, то их стоит запускать параллельно.
// Если же потоки работают с общими данными, которые могут быть повреждены при одновременном доступе,
// то стоит использовать механизмы синхронизации, такие как ReentrantLock.


// здесь потоки ждут заваршения других и выполняются последовательно
public class Main {
    public static void main(String[] args) {

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                MobileCall.mobileCall();

            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                SkypeCall.skypeCall();

            }
        });
        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                ViberCall.viberCall();

            }
        });
        thread1.start();
        thread2.start();
        thread3.start();

    }
}
